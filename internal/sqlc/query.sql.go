// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createAuthzHistory = `-- name: CreateAuthzHistory :execresult
INSERT INTO authorization_history (user_id, client_id) VALUES (
    ?, ?
)
`

type CreateAuthzHistoryParams struct {
	UserID   int64
	ClientID string
}

func (q *Queries) CreateAuthzHistory(ctx context.Context, arg CreateAuthzHistoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAuthzHistory, arg.UserID, arg.ClientID)
}

const createClient = `-- name: CreateClient :execresult
INSERT INTO client (
    id,
    secret_hash,
    name,
    auth_callback_urls,
    logout_callback_urls,
    picture_url,
    backchannel_logout_url,
    token_expiration
) VALUES (
	?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateClientParams struct {
	ID                   string
	SecretHash           string
	Name                 string
	AuthCallbackUrls     string
	LogoutCallbackUrls   string
	PictureUrl           sql.NullString
	BackchannelLogoutUrl sql.NullString
	TokenExpiration      int64
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createClient,
		arg.ID,
		arg.SecretHash,
		arg.Name,
		arg.AuthCallbackUrls,
		arg.LogoutCallbackUrls,
		arg.PictureUrl,
		arg.BackchannelLogoutUrl,
		arg.TokenExpiration,
	)
}

const createSession = `-- name: CreateSession :execresult
INSERT INTO session (id, user_id, client_id, expires_at, os, browser) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateSessionParams struct {
	ID        string
	UserID    int64
	ClientID  sql.NullString
	ExpiresAt time.Time
	Os        sql.NullString
	Browser   sql.NullString
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.ClientID,
		arg.ExpiresAt,
		arg.Os,
		arg.Browser,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO user (email, hashed_password, avatar_url) VALUES (
    ?, ?, ?
)
`

type CreateUserParams struct {
	Email          string
	HashedPassword sql.NullString
	AvatarUrl      sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.Email, arg.HashedPassword, arg.AvatarUrl)
}

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM client
WHERE id = ?
`

func (q *Queries) DeleteClient(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteClient, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM session
WHERE id = ? OR expires_at <= NOW()
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const getAuthzHistory = `-- name: GetAuthzHistory :one
SELECT user_id, client_id, authorized_at FROM authorization_history
WHERE user_id = ? AND client_id = ?
`

type GetAuthzHistoryParams struct {
	UserID   int64
	ClientID string
}

func (q *Queries) GetAuthzHistory(ctx context.Context, arg GetAuthzHistoryParams) (AuthorizationHistory, error) {
	row := q.db.QueryRowContext(ctx, getAuthzHistory, arg.UserID, arg.ClientID)
	var i AuthorizationHistory
	err := row.Scan(&i.UserID, &i.ClientID, &i.AuthorizedAt)
	return i, err
}

const getClient = `-- name: GetClient :one
SELECT id, secret_hash, name, picture_url, auth_callback_urls, logout_callback_urls, backchannel_logout_url, token_expiration, created_at FROM client
WHERE id = ?
`

func (q *Queries) GetClient(ctx context.Context, id string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.SecretHash,
		&i.Name,
		&i.PictureUrl,
		&i.AuthCallbackUrls,
		&i.LogoutCallbackUrls,
		&i.BackchannelLogoutUrl,
		&i.TokenExpiration,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByName = `-- name: GetClientByName :one
SELECT id, secret_hash, name, picture_url, auth_callback_urls, logout_callback_urls, backchannel_logout_url, token_expiration, created_at FROM client
WHERE name = ?
`

func (q *Queries) GetClientByName(ctx context.Context, name string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByName, name)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.SecretHash,
		&i.Name,
		&i.PictureUrl,
		&i.AuthCallbackUrls,
		&i.LogoutCallbackUrls,
		&i.BackchannelLogoutUrl,
		&i.TokenExpiration,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByNameForUnmatchingID = `-- name: GetClientByNameForUnmatchingID :one
SELECT id, secret_hash, name, picture_url, auth_callback_urls, logout_callback_urls, backchannel_logout_url, token_expiration, created_at FROM client
WHERE name = ? AND id != ?
`

type GetClientByNameForUnmatchingIDParams struct {
	Name string
	ID   string
}

func (q *Queries) GetClientByNameForUnmatchingID(ctx context.Context, arg GetClientByNameForUnmatchingIDParams) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByNameForUnmatchingID, arg.Name, arg.ID)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.SecretHash,
		&i.Name,
		&i.PictureUrl,
		&i.AuthCallbackUrls,
		&i.LogoutCallbackUrls,
		&i.BackchannelLogoutUrl,
		&i.TokenExpiration,
		&i.CreatedAt,
	)
	return i, err
}

const getClients = `-- name: GetClients :many
SELECT id, secret_hash, name, picture_url, auth_callback_urls, logout_callback_urls, backchannel_logout_url, token_expiration, created_at FROM client
`

func (q *Queries) GetClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, getClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.SecretHash,
			&i.Name,
			&i.PictureUrl,
			&i.AuthCallbackUrls,
			&i.LogoutCallbackUrls,
			&i.BackchannelLogoutUrl,
			&i.TokenExpiration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, created_at, expires_at, client_id, os, browser FROM session
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClientID,
		&i.Os,
		&i.Browser,
	)
	return i, err
}

const getSessionWithClient = `-- name: GetSessionWithClient :one
SELECT
    session.id,
    client.id as client_id,
    client.name as client_name,
    client.logout_callback_urls,
    client.backchannel_logout_url
FROM
    session
INNER JOIN client
ON session.client_id = client.id
WHERE session.id = ?
`

type GetSessionWithClientRow struct {
	ID                   string
	ClientID             string
	ClientName           string
	LogoutCallbackUrls   string
	BackchannelLogoutUrl sql.NullString
}

func (q *Queries) GetSessionWithClient(ctx context.Context, id string) (GetSessionWithClientRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionWithClient, id)
	var i GetSessionWithClientRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientName,
		&i.LogoutCallbackUrls,
		&i.BackchannelLogoutUrl,
	)
	return i, err
}

const getSessionWithClientForUserID = `-- name: GetSessionWithClientForUserID :many
SELECT
    session.id,
    session.created_at,
    session.expires_at,
    session.os,
    session.browser,
    client.name as client_name
FROM
    session
LEFT JOIN client
ON session.client_id = client.id
WHERE session.user_id = ?
`

type GetSessionWithClientForUserIDRow struct {
	ID         string
	CreatedAt  time.Time
	ExpiresAt  time.Time
	Os         sql.NullString
	Browser    sql.NullString
	ClientName sql.NullString
}

func (q *Queries) GetSessionWithClientForUserID(ctx context.Context, userID int64) ([]GetSessionWithClientForUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionWithClientForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionWithClientForUserIDRow
	for rows.Next() {
		var i GetSessionWithClientForUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Os,
			&i.Browser,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionWithOptionalClient = `-- name: GetSessionWithOptionalClient :one
SELECT
    session.id,
    client.id as client_id,
    client.name as client_name,
    client.logout_callback_urls,
    client.backchannel_logout_url
FROM
    session
LEFT JOIN client
ON session.client_id = client.id
WHERE session.id = ?
`

type GetSessionWithOptionalClientRow struct {
	ID                   string
	ClientID             sql.NullString
	ClientName           sql.NullString
	LogoutCallbackUrls   sql.NullString
	BackchannelLogoutUrl sql.NullString
}

func (q *Queries) GetSessionWithOptionalClient(ctx context.Context, id string) (GetSessionWithOptionalClientRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionWithOptionalClient, id)
	var i GetSessionWithOptionalClientRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientName,
		&i.LogoutCallbackUrls,
		&i.BackchannelLogoutUrl,
	)
	return i, err
}

const getSessionWithUser = `-- name: GetSessionWithUser :one
SELECT
    session.id,
    session.expires_at,
    user.id as user_id,
    user.email,
    user.avatar_url
FROM
    session
INNER JOIN user
ON session.user_id = user.id
WHERE session.id = ?
`

type GetSessionWithUserRow struct {
	ID        string
	ExpiresAt time.Time
	UserID    int64
	Email     string
	AvatarUrl sql.NullString
}

func (q *Queries) GetSessionWithUser(ctx context.Context, id string) (GetSessionWithUserRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionWithUser, id)
	var i GetSessionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.UserID,
		&i.Email,
		&i.AvatarUrl,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, avatar_url, hashed_password, is_admin, created_at FROM user
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.AvatarUrl,
		&i.HashedPassword,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAndClientCount = `-- name: GetUserAndClientCount :one
SELECT
    (SELECT COUNT(*) FROM user) as user_count,
    (SELECT COUNT(*) FROM client) as client_count
`

type GetUserAndClientCountRow struct {
	UserCount   int64
	ClientCount int64
}

func (q *Queries) GetUserAndClientCount(ctx context.Context) (GetUserAndClientCountRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAndClientCount)
	var i GetUserAndClientCountRow
	err := row.Scan(&i.UserCount, &i.ClientCount)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, avatar_url, hashed_password, is_admin, created_at FROM user
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.AvatarUrl,
		&i.HashedPassword,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, email, avatar_url, hashed_password, is_admin, created_at FROM user
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.AvatarUrl,
			&i.HashedPassword,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClient = `-- name: UpdateClient :exec
UPDATE client
SET name = ?,
    auth_callback_urls = ?,
    logout_callback_urls = ?,
    picture_url = ?,
    backchannel_logout_url = ?,
    token_expiration = ?
WHERE id = ?
`

type UpdateClientParams struct {
	Name                 string
	AuthCallbackUrls     string
	LogoutCallbackUrls   string
	PictureUrl           sql.NullString
	BackchannelLogoutUrl sql.NullString
	TokenExpiration      int64
	ID                   string
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) error {
	_, err := q.db.ExecContext(ctx, updateClient,
		arg.Name,
		arg.AuthCallbackUrls,
		arg.LogoutCallbackUrls,
		arg.PictureUrl,
		arg.BackchannelLogoutUrl,
		arg.TokenExpiration,
		arg.ID,
	)
	return err
}

const updateUserPasswordHash = `-- name: UpdateUserPasswordHash :exec
UPDATE user
SET hashed_password = ?
WHERE id = ?
`

type UpdateUserPasswordHashParams struct {
	HashedPassword sql.NullString
	ID             int64
}

func (q *Queries) UpdateUserPasswordHash(ctx context.Context, arg UpdateUserPasswordHashParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPasswordHash, arg.HashedPassword, arg.ID)
	return err
}
